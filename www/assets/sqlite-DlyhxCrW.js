const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/web-CtX0dgfp.js","assets/index-BQYoTwzb.js","assets/index-D_12Ai1B.css"])))=>i.map(i=>d[i]);
import{_ as ce,d as le}from"./index-BQYoTwzb.js";var v;(function(r){r.Unimplemented="UNIMPLEMENTED",r.Unavailable="UNAVAILABLE"})(v||(v={}));class M extends Error{constructor(e,t,s){super(e),this.message=e,this.code=t,this.data=s}}const de=r=>{var e,t;return r?.androidBridge?"android":!((t=(e=r?.webkit)===null||e===void 0?void 0:e.messageHandlers)===null||t===void 0)&&t.bridge?"ios":"web"},ue=r=>{const e=r.CapacitorCustomPlatform||null,t=r.Capacitor||{},s=t.Plugins=t.Plugins||{},n=()=>e!==null?e.name:de(r),i=()=>n()!=="web",o=l=>{const d=u.get(l);return!!(d?.platforms.has(n())||a(l))},a=l=>{var d;return(d=t.PluginHeaders)===null||d===void 0?void 0:d.find(L=>L.name===l)},c=l=>r.console.error(l),u=new Map,p=(l,d={})=>{const L=u.get(l);if(L)return console.warn(`Capacitor plugin "${l}" already registered. Cannot register plugins twice.`),L.proxy;const b=n(),P=a(l);let g;const ie=async()=>(!g&&b in d?g=typeof d[b]=="function"?g=await d[b]():g=d[b]:e!==null&&!g&&"web"in d&&(g=typeof d.web=="function"?g=await d.web():g=d.web),g),oe=(h,m)=>{var f,w;if(P){const E=P?.methods.find(y=>m===y.name);if(E)return E.rtype==="promise"?y=>t.nativePromise(l,m.toString(),y):(y,S)=>t.nativeCallback(l,m.toString(),y,S);if(h)return(f=h[m])===null||f===void 0?void 0:f.bind(h)}else{if(h)return(w=h[m])===null||w===void 0?void 0:w.bind(h);throw new M(`"${l}" plugin is not implemented on ${b}`,v.Unimplemented)}},R=h=>{let m;const f=(...w)=>{const E=ie().then(y=>{const S=oe(y,h);if(S){const C=S(...w);return m=C?.remove,C}else throw new M(`"${l}.${h}()" is not implemented on ${b}`,v.Unimplemented)});return h==="addListener"&&(E.remove=async()=>m()),E};return f.toString=()=>`${h.toString()}() { [capacitor code] }`,Object.defineProperty(f,"name",{value:h,writable:!1,configurable:!1}),f},X=R("addListener"),Q=R("removeListener"),ae=(h,m)=>{const f=X({eventName:h},m),w=async()=>{const y=await f;Q({eventName:h,callbackId:y},m)},E=new Promise(y=>f.then(()=>y({remove:w})));return E.remove=async()=>{console.warn("Using addListener() without 'await' is deprecated."),await w()},E},O=new Proxy({},{get(h,m){switch(m){case"$$typeof":return;case"toJSON":return()=>({});case"addListener":return P?ae:X;case"removeListener":return Q;default:return R(m)}}});return s[l]=O,u.set(l,{name:l,proxy:O,platforms:new Set([...Object.keys(d),...P?[b]:[]])}),O};return t.convertFileSrc||(t.convertFileSrc=l=>l),t.getPlatform=n,t.handleError=c,t.isNativePlatform=i,t.isPluginAvailable=o,t.registerPlugin=p,t.Exception=M,t.DEBUG=!!t.DEBUG,t.isLoggingEnabled=!!t.isLoggingEnabled,t},he=r=>r.Capacitor=ue(r),x=he(typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{}),A=x.registerPlugin;class W{constructor(){this.listeners={},this.retainedEventArguments={},this.windowListeners={}}addListener(e,t){let s=!1;this.listeners[e]||(this.listeners[e]=[],s=!0),this.listeners[e].push(t);const i=this.windowListeners[e];i&&!i.registered&&this.addWindowListener(i),s&&this.sendRetainedArgumentsForEvent(e);const o=async()=>this.removeListener(e,t);return Promise.resolve({remove:o})}async removeAllListeners(){this.listeners={};for(const e in this.windowListeners)this.removeWindowListener(this.windowListeners[e]);this.windowListeners={}}notifyListeners(e,t,s){const n=this.listeners[e];if(!n){if(s){let i=this.retainedEventArguments[e];i||(i=[]),i.push(t),this.retainedEventArguments[e]=i}return}n.forEach(i=>i(t))}hasListeners(e){var t;return!!(!((t=this.listeners[e])===null||t===void 0)&&t.length)}registerWindowListener(e,t){this.windowListeners[t]={registered:!1,windowEventName:e,pluginEventName:t,handler:s=>{this.notifyListeners(t,s)}}}unimplemented(e="not implemented"){return new x.Exception(e,v.Unimplemented)}unavailable(e="not available"){return new x.Exception(e,v.Unavailable)}async removeListener(e,t){const s=this.listeners[e];if(!s)return;const n=s.indexOf(t);this.listeners[e].splice(n,1),this.listeners[e].length||this.removeWindowListener(this.windowListeners[e])}addWindowListener(e){window.addEventListener(e.windowEventName,e.handler),e.registered=!0}removeWindowListener(e){e&&(window.removeEventListener(e.windowEventName,e.handler),e.registered=!1)}sendRetainedArgumentsForEvent(e){const t=this.retainedEventArguments[e];t&&(delete this.retainedEventArguments[e],t.forEach(s=>{this.notifyListeners(e,s)}))}}const K=r=>encodeURIComponent(r).replace(/%(2[346B]|5E|60|7C)/g,decodeURIComponent).replace(/[()]/g,escape),V=r=>r.replace(/(%[\dA-F]{2})+/gi,decodeURIComponent);class me extends W{async getCookies(){const e=document.cookie,t={};return e.split(";").forEach(s=>{if(s.length<=0)return;let[n,i]=s.replace(/=/,"CAP_COOKIE").split("CAP_COOKIE");n=V(n).trim(),i=V(i).trim(),t[n]=i}),t}async setCookie(e){try{const t=K(e.key),s=K(e.value),n=`; expires=${(e.expires||"").replace("expires=","")}`,i=(e.path||"/").replace("path=",""),o=e.url!=null&&e.url.length>0?`domain=${e.url}`:"";document.cookie=`${t}=${s||""}${n}; path=${i}; ${o};`}catch(t){return Promise.reject(t)}}async deleteCookie(e){try{document.cookie=`${e.key}=; Max-Age=0`}catch(t){return Promise.reject(t)}}async clearCookies(){try{const e=document.cookie.split(";")||[];for(const t of e)document.cookie=t.replace(/^ +/,"").replace(/=.*/,`=;expires=${new Date().toUTCString()};path=/`)}catch(e){return Promise.reject(e)}}async clearAllCookies(){try{await this.clearCookies()}catch(e){return Promise.reject(e)}}}A("CapacitorCookies",{web:()=>new me});const ye=async r=>new Promise((e,t)=>{const s=new FileReader;s.onload=()=>{const n=s.result;e(n.indexOf(",")>=0?n.split(",")[1]:n)},s.onerror=n=>t(n),s.readAsDataURL(r)}),fe=(r={})=>{const e=Object.keys(r);return Object.keys(r).map(n=>n.toLocaleLowerCase()).reduce((n,i,o)=>(n[i]=r[e[o]],n),{})},ge=(r,e=!0)=>r?Object.entries(r).reduce((s,n)=>{const[i,o]=n;let a,c;return Array.isArray(o)?(c="",o.forEach(u=>{a=e?encodeURIComponent(u):u,c+=`${i}=${a}&`}),c.slice(0,-1)):(a=e?encodeURIComponent(o):o,c=`${i}=${a}`),`${s}&${c}`},"").substr(1):null,we=(r,e={})=>{const t=Object.assign({method:r.method||"GET",headers:r.headers},e),n=fe(r.headers)["content-type"]||"";if(typeof r.data=="string")t.body=r.data;else if(n.includes("application/x-www-form-urlencoded")){const i=new URLSearchParams;for(const[o,a]of Object.entries(r.data||{}))i.set(o,a);t.body=i.toString()}else if(n.includes("multipart/form-data")||r.data instanceof FormData){const i=new FormData;if(r.data instanceof FormData)r.data.forEach((a,c)=>{i.append(c,a)});else for(const a of Object.keys(r.data))i.append(a,r.data[a]);t.body=i;const o=new Headers(t.headers);o.delete("content-type"),t.headers=o}else(n.includes("application/json")||typeof r.data=="object")&&(t.body=JSON.stringify(r.data));return t};class Ee extends W{async request(e){const t=we(e,e.webFetchExtra),s=ge(e.params,e.shouldEncodeUrlParams),n=s?`${e.url}?${s}`:e.url,i=await fetch(n,t),o=i.headers.get("content-type")||"";let{responseType:a="text"}=i.ok?e:{};o.includes("application/json")&&(a="json");let c,u;switch(a){case"arraybuffer":case"blob":u=await i.blob(),c=await ye(u);break;case"json":c=await i.json();break;default:c=await i.text()}const p={};return i.headers.forEach((l,d)=>{p[d]=l}),{data:c,headers:p,status:i.status,url:i.url}}async get(e){return this.request(Object.assign(Object.assign({},e),{method:"GET"}))}async post(e){return this.request(Object.assign(Object.assign({},e),{method:"POST"}))}async put(e){return this.request(Object.assign(Object.assign({},e),{method:"PUT"}))}async patch(e){return this.request(Object.assign(Object.assign({},e),{method:"PATCH"}))}async delete(e){return this.request(Object.assign(Object.assign({},e),{method:"DELETE"}))}}A("CapacitorHttp",{web:()=>new Ee});var G;(function(r){r.Dark="DARK",r.Light="LIGHT",r.Default="DEFAULT"})(G||(G={}));var H;(function(r){r.StatusBar="StatusBar",r.NavigationBar="NavigationBar"})(H||(H={}));class be extends W{async setStyle(){this.unavailable("not available for web")}async setAnimation(){this.unavailable("not available for web")}async show(){this.unavailable("not available for web")}async hide(){this.unavailable("not available for web")}}A("SystemBars",{web:()=>new be});class Pe{constructor(e){this.sqlite=e,this._connectionDict=new Map}async initWebStore(){try{return await this.sqlite.initWebStore(),Promise.resolve()}catch(e){return Promise.reject(e)}}async saveToStore(e){try{return await this.sqlite.saveToStore({database:e}),Promise.resolve()}catch(t){return Promise.reject(t)}}async saveToLocalDisk(e){try{return await this.sqlite.saveToLocalDisk({database:e}),Promise.resolve()}catch(t){return Promise.reject(t)}}async getFromLocalDiskToStore(e){const t=e??!0;try{return await this.sqlite.getFromLocalDiskToStore({overwrite:t}),Promise.resolve()}catch(s){return Promise.reject(s)}}async echo(e){try{const t=await this.sqlite.echo({value:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async isSecretStored(){try{const e=await this.sqlite.isSecretStored();return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async setEncryptionSecret(e){try{return await this.sqlite.setEncryptionSecret({passphrase:e}),Promise.resolve()}catch(t){return Promise.reject(t)}}async changeEncryptionSecret(e,t){try{return await this.sqlite.changeEncryptionSecret({passphrase:e,oldpassphrase:t}),Promise.resolve()}catch(s){return Promise.reject(s)}}async clearEncryptionSecret(){try{return await this.sqlite.clearEncryptionSecret(),Promise.resolve()}catch(e){return Promise.reject(e)}}async checkEncryptionSecret(e){try{const t=await this.sqlite.checkEncryptionSecret({passphrase:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async addUpgradeStatement(e,t){try{return e.endsWith(".db")&&(e=e.slice(0,-3)),await this.sqlite.addUpgradeStatement({database:e,upgrade:t}),Promise.resolve()}catch(s){return Promise.reject(s)}}async createConnection(e,t,s,n,i){try{e.endsWith(".db")&&(e=e.slice(0,-3)),await this.sqlite.createConnection({database:e,encrypted:t,mode:s,version:n,readonly:i});const o=new z(e,i,this.sqlite),a=i?`RO_${e}`:`RW_${e}`;return this._connectionDict.set(a,o),Promise.resolve(o)}catch(o){return Promise.reject(o)}}async closeConnection(e,t){try{e.endsWith(".db")&&(e=e.slice(0,-3)),await this.sqlite.closeConnection({database:e,readonly:t});const s=t?`RO_${e}`:`RW_${e}`;return this._connectionDict.delete(s),Promise.resolve()}catch(s){return Promise.reject(s)}}async isConnection(e,t){const s={};e.endsWith(".db")&&(e=e.slice(0,-3));const n=t?`RO_${e}`:`RW_${e}`;return s.result=this._connectionDict.has(n),Promise.resolve(s)}async retrieveConnection(e,t){e.endsWith(".db")&&(e=e.slice(0,-3));const s=t?`RO_${e}`:`RW_${e}`;if(this._connectionDict.has(s)){const n=this._connectionDict.get(s);return typeof n<"u"?Promise.resolve(n):Promise.reject(`Connection ${e} is undefined`)}else return Promise.reject(`Connection ${e} does not exist`)}async getNCDatabasePath(e,t){try{const s=await this.sqlite.getNCDatabasePath({path:e,database:t});return Promise.resolve(s)}catch(s){return Promise.reject(s)}}async createNCConnection(e,t){try{await this.sqlite.createNCConnection({databasePath:e,version:t});const s=new z(e,!0,this.sqlite),n=`RO_${e})`;return this._connectionDict.set(n,s),Promise.resolve(s)}catch(s){return Promise.reject(s)}}async closeNCConnection(e){try{await this.sqlite.closeNCConnection({databasePath:e});const t=`RO_${e})`;return this._connectionDict.delete(t),Promise.resolve()}catch(t){return Promise.reject(t)}}async isNCConnection(e){const t={},s=`RO_${e})`;return t.result=this._connectionDict.has(s),Promise.resolve(t)}async retrieveNCConnection(e){if(this._connectionDict.has(e)){const t=`RO_${e})`,s=this._connectionDict.get(t);return typeof s<"u"?Promise.resolve(s):Promise.reject(`Connection ${e} is undefined`)}else return Promise.reject(`Connection ${e} does not exist`)}async isNCDatabase(e){try{const t=await this.sqlite.isNCDatabase({databasePath:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async retrieveAllConnections(){return this._connectionDict}async closeAllConnections(){const e=new Map;try{for(const t of this._connectionDict.keys()){const s=t.substring(3),n=t.substring(0,3)==="RO_";await this.sqlite.closeConnection({database:s,readonly:n}),e.set(t,null)}for(const t of e.keys())this._connectionDict.delete(t);return Promise.resolve()}catch(t){return Promise.reject(t)}}async checkConnectionsConsistency(){try{const e=[...this._connectionDict.keys()],t=[],s=[];for(const i of e)t.push(i.substring(0,2)),s.push(i.substring(3));const n=await this.sqlite.checkConnectionsConsistency({dbNames:s,openModes:t});return n.result||(this._connectionDict=new Map),Promise.resolve(n)}catch(e){return this._connectionDict=new Map,Promise.reject(e)}}async importFromJson(e){try{const t=await this.sqlite.importFromJson({jsonstring:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async isJsonValid(e){try{const t=await this.sqlite.isJsonValid({jsonstring:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async copyFromAssets(e){const t=e??!0;try{return await this.sqlite.copyFromAssets({overwrite:t}),Promise.resolve()}catch(s){return Promise.reject(s)}}async getFromHTTPRequest(e,t){const s=t??!0;try{return await this.sqlite.getFromHTTPRequest({url:e,overwrite:s}),Promise.resolve()}catch(n){return Promise.reject(n)}}async isDatabaseEncrypted(e){e.endsWith(".db")&&(e=e.slice(0,-3));try{const t=await this.sqlite.isDatabaseEncrypted({database:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async isInConfigEncryption(){try{const e=await this.sqlite.isInConfigEncryption();return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isInConfigBiometricAuth(){try{const e=await this.sqlite.isInConfigBiometricAuth();return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isDatabase(e){e.endsWith(".db")&&(e=e.slice(0,-3));try{const t=await this.sqlite.isDatabase({database:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async getDatabaseList(){try{const t=(await this.sqlite.getDatabaseList()).values;t.sort();const s={values:t};return Promise.resolve(s)}catch(e){return Promise.reject(e)}}async getMigratableDbList(e){const t=e||"default";try{const s=await this.sqlite.getMigratableDbList({folderPath:t});return Promise.resolve(s)}catch(s){return Promise.reject(s)}}async addSQLiteSuffix(e,t){const s=e||"default",n=t||[];try{const i=await this.sqlite.addSQLiteSuffix({folderPath:s,dbNameList:n});return Promise.resolve(i)}catch(i){return Promise.reject(i)}}async deleteOldDatabases(e,t){const s=e||"default",n=t||[];try{const i=await this.sqlite.deleteOldDatabases({folderPath:s,dbNameList:n});return Promise.resolve(i)}catch(i){return Promise.reject(i)}}async moveDatabasesAndAddSuffix(e,t){const s=e||"default",n=t||[];return this.sqlite.moveDatabasesAndAddSuffix({folderPath:s,dbNameList:n})}}class z{constructor(e,t,s){this.dbName=e,this.readonly=t,this.sqlite=s}getConnectionDBName(){return this.dbName}getConnectionReadOnly(){return this.readonly}async open(){try{return await this.sqlite.open({database:this.dbName,readonly:this.readonly}),Promise.resolve()}catch(e){return Promise.reject(e)}}async close(){try{return await this.sqlite.close({database:this.dbName,readonly:this.readonly}),Promise.resolve()}catch(e){return Promise.reject(e)}}async beginTransaction(){try{const e=await this.sqlite.beginTransaction({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async commitTransaction(){try{const e=await this.sqlite.commitTransaction({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async rollbackTransaction(){try{const e=await this.sqlite.rollbackTransaction({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isTransactionActive(){try{const e=await this.sqlite.isTransactionActive({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async loadExtension(e){try{return await this.sqlite.loadExtension({database:this.dbName,path:e,readonly:this.readonly}),Promise.resolve()}catch(t){return Promise.reject(t)}}async enableLoadExtension(e){try{return await this.sqlite.enableLoadExtension({database:this.dbName,toggle:e,readonly:this.readonly}),Promise.resolve()}catch(t){return Promise.reject(t)}}async getUrl(){try{const e=await this.sqlite.getUrl({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async getVersion(){try{const e=await this.sqlite.getVersion({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async getTableList(){try{const e=await this.sqlite.getTableList({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async execute(e,t=!0,s=!0){try{if(this.readonly)return Promise.reject("not allowed in read-only mode");{const n=await this.sqlite.execute({database:this.dbName,statements:e,transaction:t,readonly:!1,isSQL92:s});return Promise.resolve(n)}}catch(n){return Promise.reject(n)}}async query(e,t,s=!0){let n;try{return t&&t.length>0?n=await this.sqlite.query({database:this.dbName,statement:e,values:t,readonly:this.readonly,isSQL92:!0}):n=await this.sqlite.query({database:this.dbName,statement:e,values:[],readonly:this.readonly,isSQL92:s}),n=await this.reorderRows(n),Promise.resolve(n)}catch(i){return Promise.reject(i)}}async run(e,t,s=!0,n="no",i=!0){let o;try{return this.readonly?Promise.reject("not allowed in read-only mode"):(t&&t.length>0?o=await this.sqlite.run({database:this.dbName,statement:e,values:t,transaction:s,readonly:!1,returnMode:n,isSQL92:!0}):o=await this.sqlite.run({database:this.dbName,statement:e,values:[],transaction:s,readonly:!1,returnMode:n,isSQL92:i}),o.changes=await this.reorderRows(o.changes),Promise.resolve(o))}catch(a){return Promise.reject(a)}}async executeSet(e,t=!0,s="no",n=!0){let i;try{return this.readonly?Promise.reject("not allowed in read-only mode"):(i=await this.sqlite.executeSet({database:this.dbName,set:e,transaction:t,readonly:!1,returnMode:s,isSQL92:n}),i.changes=await this.reorderRows(i.changes),Promise.resolve(i))}catch(o){return Promise.reject(o)}}async isExists(){try{const e=await this.sqlite.isDBExists({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isTable(e){try{const t=await this.sqlite.isTableExists({database:this.dbName,table:e,readonly:this.readonly});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async isDBOpen(){try{const e=await this.sqlite.isDBOpen({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async delete(){try{return this.readonly?Promise.reject("not allowed in read-only mode"):(await this.sqlite.deleteDatabase({database:this.dbName,readonly:!1}),Promise.resolve())}catch(e){return Promise.reject(e)}}async createSyncTable(){try{if(this.readonly)return Promise.reject("not allowed in read-only mode");{const e=await this.sqlite.createSyncTable({database:this.dbName,readonly:!1});return Promise.resolve(e)}}catch(e){return Promise.reject(e)}}async setSyncDate(e){try{return this.readonly?Promise.reject("not allowed in read-only mode"):(await this.sqlite.setSyncDate({database:this.dbName,syncdate:e,readonly:!1}),Promise.resolve())}catch(t){return Promise.reject(t)}}async getSyncDate(){try{const e=await this.sqlite.getSyncDate({database:this.dbName,readonly:this.readonly});let t="";return e.syncDate>0&&(t=new Date(e.syncDate*1e3).toISOString()),Promise.resolve(t)}catch(e){return Promise.reject(e)}}async exportToJson(e,t=!1){try{const s=await this.sqlite.exportToJson({database:this.dbName,jsonexportmode:e,readonly:this.readonly,encrypted:t});return Promise.resolve(s)}catch(s){return Promise.reject(s)}}async deleteExportedRows(){try{return this.readonly?Promise.reject("not allowed in read-only mode"):(await this.sqlite.deleteExportedRows({database:this.dbName,readonly:!1}),Promise.resolve())}catch(e){return Promise.reject(e)}}async executeTransaction(e,t=!0){let s=0,n=!1;if(this.readonly)return Promise.reject("not allowed in read-only mode");if(await this.sqlite.beginTransaction({database:this.dbName}),n=await this.sqlite.isTransactionActive({database:this.dbName}),!n)return Promise.reject("After Begin Transaction, no transaction active");try{for(const a of e){if(typeof a!="object"||!("statement"in a))throw new Error("Error a task.statement must be provided");if("values"in a&&a.values&&a.values.length>0){const c=a.statement.toUpperCase().includes("RETURNING")?"all":"no",u=await this.sqlite.run({database:this.dbName,statement:a.statement,values:a.values,transaction:!1,readonly:!1,returnMode:c,isSQL92:t});if(u.changes.changes<0)throw new Error("Error in transaction method run ");s+=u.changes.changes}else{const c=await this.sqlite.execute({database:this.dbName,statements:a.statement,transaction:!1,readonly:!1});if(c.changes.changes<0)throw new Error("Error in transaction method execute ");s+=c.changes.changes}}const i=await this.sqlite.commitTransaction({database:this.dbName});s+=i.changes.changes;const o={changes:{changes:s}};return Promise.resolve(o)}catch(i){const o=i.message?i.message:i;return await this.sqlite.rollbackTransaction({database:this.dbName}),Promise.reject(o)}}async reorderRows(e){const t=e;if(e?.values&&typeof e.values[0]=="object"&&Object.keys(e.values[0]).includes("ios_columns")){const s=e.values[0].ios_columns,n=[];for(let i=1;i<e.values.length;i++){const o=e.values[i],a={};for(const c of s)a[c]=o[c];n.push(a)}t.values=n}return Promise.resolve(t)}}const ve=A("CapacitorSQLite",{web:()=>ce(()=>import("./web-CtX0dgfp.js"),__vite__mapDeps([0,1,2])).then(r=>new r.CapacitorSQLiteWeb),electron:()=>window.CapacitorCustomPlatform.plugins.CapacitorSQLite}),Te={version:1,description:()=>"Create initial schema with accounts, categories, and transactions tables",up:()=>[`CREATE TABLE IF NOT EXISTS accounts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL UNIQUE,
      type TEXT NOT NULL,
      balance REAL DEFAULT 0,
      currency TEXT DEFAULT 'USD',
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )`,`CREATE TABLE IF NOT EXISTS categories (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL UNIQUE,
      type TEXT NOT NULL,
      color TEXT,
      icon TEXT,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )`,`CREATE TABLE IF NOT EXISTS transactions (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      account_id INTEGER NOT NULL,
      category_id INTEGER,
      type TEXT NOT NULL,
      amount REAL NOT NULL,
      description TEXT,
      date DATE NOT NULL,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (account_id) REFERENCES accounts(id) ON DELETE CASCADE,
      FOREIGN KEY (category_id) REFERENCES categories(id) ON DELETE SET NULL
    )`,"CREATE INDEX IF NOT EXISTS idx_transactions_account_id ON transactions(account_id)","CREATE INDEX IF NOT EXISTS idx_transactions_date ON transactions(date)","CREATE INDEX IF NOT EXISTS idx_transactions_category_id ON transactions(category_id)"],down:()=>["DROP INDEX IF EXISTS idx_transactions_category_id","DROP INDEX IF EXISTS idx_transactions_date","DROP INDEX IF EXISTS idx_transactions_account_id","DROP TABLE IF EXISTS transactions","DROP TABLE IF EXISTS categories","DROP TABLE IF EXISTS accounts"]},pe=[Te];async function Le(r){await r.execute(`
    CREATE TABLE IF NOT EXISTS migrations (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      version INTEGER NOT NULL UNIQUE,
      description TEXT NOT NULL,
      executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      status TEXT DEFAULT 'completed'
    )
  `)}async function Se(r){try{return((await r.query("SELECT version FROM migrations ORDER BY version ASC")).values||[]).map(t=>t.version)}catch{return[]}}async function Ce(r){try{console.log("[Migrations] Initializing migrations table..."),await Le(r);const e=await Se(r);console.log("[Migrations] Applied versions:",e);const t=pe.filter(s=>!e.includes(s.version));if(t.length===0){console.log("[Migrations] All migrations are up to date");return}console.log("[Migrations] Running",t.length,"pending migration(s)...");for(const s of t)try{console.log(`[Migrations] Executing migration ${s.version}...`),await r.execute("BEGIN TRANSACTION");const n=s.up(),i=Array.isArray(n)?n:[n];for(const a of i)await r.execute(a);const o=s.description();await r.run("INSERT INTO migrations (version, description, status) VALUES (?, ?, ?)",[s.version,o,"completed"]),await r.execute("COMMIT"),console.log(`[Migrations] Migration ${s.version} completed: ${o}`)}catch(n){throw await r.execute("ROLLBACK"),console.error(`[Migrations] Migration ${s.version} failed:`,n),new Error(`Migration ${s.version} failed: ${n instanceof Error?n.message:String(n)}`)}console.log("[Migrations] All pending migrations completed successfully")}catch(e){throw console.error("[Migrations] Migration runner error:",e),e}}async function De(r){try{return(await r.query("SELECT MAX(version) as latestVersion FROM migrations")).values?.[0]?.latestVersion||0}catch{return 0}}const D="fcl";let T=null,I=null;async function Ie(){try{if(I=new Pe(ve),(await I.isDatabase(D)).result||(console.log("[Database] Creating new database:",D),await I.createConnection(D,!1,"no-encryption",1,!1)),T=await I.retrieveConnection(D,!1),!T)throw new Error("Failed to retrieve database connection");await T.open(),console.log("[Database] Database opened successfully"),console.log("[Database] Running migrations..."),await Ce(T);const t=await De(T);console.log("[Database] Database version:",t)}catch(r){throw console.error("[Database] Initialization error:",r),r}}const U=(r,e)=>e.some(t=>r instanceof t);let Y,J;function Ne(){return Y||(Y=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function Ae(){return J||(J=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const k=new WeakMap,_=new WeakMap,j=new WeakMap;function je(r){const e=new Promise((t,s)=>{const n=()=>{r.removeEventListener("success",i),r.removeEventListener("error",o)},i=()=>{t(N(r.result)),n()},o=()=>{s(r.error),n()};r.addEventListener("success",i),r.addEventListener("error",o)});return j.set(e,r),e}function Re(r){if(k.has(r))return;const e=new Promise((t,s)=>{const n=()=>{r.removeEventListener("complete",i),r.removeEventListener("error",o),r.removeEventListener("abort",o)},i=()=>{t(),n()},o=()=>{s(r.error||new DOMException("AbortError","AbortError")),n()};r.addEventListener("complete",i),r.addEventListener("error",o),r.addEventListener("abort",o)});k.set(r,e)}let B={get(r,e,t){if(r instanceof IDBTransaction){if(e==="done")return k.get(r);if(e==="store")return t.objectStoreNames[1]?void 0:t.objectStore(t.objectStoreNames[0])}return N(r[e])},set(r,e,t){return r[e]=t,!0},has(r,e){return r instanceof IDBTransaction&&(e==="done"||e==="store")?!0:e in r}};function re(r){B=r(B)}function Oe(r){return Ae().includes(r)?function(...e){return r.apply(F(this),e),N(this.request)}:function(...e){return N(r.apply(F(this),e))}}function Me(r){return typeof r=="function"?Oe(r):(r instanceof IDBTransaction&&Re(r),U(r,Ne())?new Proxy(r,B):r)}function N(r){if(r instanceof IDBRequest)return je(r);if(_.has(r))return _.get(r);const e=Me(r);return e!==r&&(_.set(r,e),j.set(e,r)),e}const F=r=>j.get(r),_e=["get","getKey","getAll","getAllKeys","count"],qe=["put","add","delete","clear"],q=new Map;function Z(r,e){if(!(r instanceof IDBDatabase&&!(e in r)&&typeof e=="string"))return;if(q.get(e))return q.get(e);const t=e.replace(/FromIndex$/,""),s=e!==t,n=qe.includes(t);if(!(t in(s?IDBIndex:IDBObjectStore).prototype)||!(n||_e.includes(t)))return;const i=async function(o,...a){const c=this.transaction(o,n?"readwrite":"readonly");let u=c.store;return s&&(u=u.index(a.shift())),(await Promise.all([u[t](...a),n&&c.done]))[0]};return q.set(e,i),i}re(r=>({...r,get:(e,t,s)=>Z(e,t)||r.get(e,t,s),has:(e,t)=>!!Z(e,t)||r.has(e,t)}));const xe=["continue","continuePrimaryKey","advance"],ee={},$=new WeakMap,se=new WeakMap,Ue={get(r,e){if(!xe.includes(e))return r[e];let t=ee[e];return t||(t=ee[e]=function(...s){$.set(this,se.get(this)[e](...s))}),t}};async function*ke(...r){let e=this;if(e instanceof IDBCursor||(e=await e.openCursor(...r)),!e)return;e=e;const t=new Proxy(e,Ue);for(se.set(t,e),j.set(t,F(e));e;)yield t,e=await($.get(t)||e.continue()),$.delete(t)}function te(r,e){return e===Symbol.asyncIterator&&U(r,[IDBIndex,IDBObjectStore,IDBCursor])||e==="iterate"&&U(r,[IDBIndex,IDBObjectStore])}re(r=>({...r,get(e,t,s){return te(e,t)?ke:r.get(e,t,s)},has(e,t){return te(e,t)||r.has(e,t)}}));function Be(){try{return!1}catch(r){return console.error("[Backup] Error during pre-boot backup check:",r),!1}}let ne=null;const Fe=le(async()=>{try{console.log("[SQLite Boot] Initializing SQLite database..."),Be()&&console.log("[SQLite Boot] Database marked for recovery check"),await Ie(),console.log("[SQLite Boot] SQLite database initialized successfully")}catch(r){throw ne=r instanceof Error?r:new Error(String(r)),console.error("[SQLite Boot] Failed to initialize SQLite database:",r),new Error(`SQLite initialization failed: ${r instanceof Error?r.message:"Unknown error"}`)}});function $e(){return ne}const Xe=Object.freeze(Object.defineProperty({__proto__:null,default:Fe,getInitError:$e},Symbol.toStringTag,{value:"Module"}));export{W,Xe as s};
